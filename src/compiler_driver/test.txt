function printf(format: const *const [u8], ..) -> u32;
function malloc(size_bytes: u64) -> *void;
function free(alloc: *void);

function fibonacci(limit: i32) -> i32 {
    let a: i32 = 0;
    let b: i32 = 1;

    while (b < limit) {
        let temp: i32 = a + b;
        a = b;
        b = temp;
    }

    return a;
}

function gcd(a: u32, b: u32) -> u32 {
    while (b >= 1) {
        let temp: u32 = a % b;
        a = b;
        b = temp;
    }

    return a;
}

function is_digit(ch: u8) -> bool {
    // oops i don't have && or || yet
    if (ch >= '0') {
        return ch <= '9';
    }
    else {
        return false;
    }
}

function get_str_len(str: *[u8]) -> u64 {
    let index: u64 = 0;
    while (str[index] != '\0') {
        index = index + 1;
    }
    return index;
}

let input: const *const [u8] = "1abc2\npqr3stu8vwx\na1b2c3d4e5f\ntreb7uchet\n";

function aoc_01_p1() {
    printf(input);

    let input_len: u64 = get_str_len(input);

    let calibration_sum: u32 = 0;

    let start_index: u64 = 0;
    while (start_index < input_len) {
        let index: u64 = start_index;

        // Find the first digit
        while (!is_digit(input[index])) {
            index = index + 1;
        }
        let calibration_value: u32 = (input[index] - '0') as u32;
        
        // Find the next '\n' character (the input is assumed to have a trailing \n)
        while (input[index] != '\n') {
            index = index + 1;
        }

        // Move the start index for the next iteration
        start_index = index + 1;

        // Backtrack to find the last digit
        index = index - 1;
        while (!is_digit(input[index])) {
            index = index - 1;
        }
        calibration_value = calibration_value * 10 + (input[index] - '0') as u32;

        // Add the found value to the sum
        calibration_sum = calibration_sum + calibration_value;
    }

    printf("[01p1] Sum of calibration values: %d\n", calibration_sum);
}

function main() -> i32 {
    input[0] = 'c';
    aoc_01_p1();

    return 0;
}
