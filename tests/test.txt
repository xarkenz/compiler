foreign struct CFile;

foreign function fopen(filename: *[u8], mode: *[u8]) -> *mut CFile;
foreign function fclose(file: *mut CFile) -> i32;
foreign function feof(file: *mut CFile) -> i32;
foreign function fgets(buffer: *mut [u8], limit: i32, file: *mut CFile) -> *mut [u8];
foreign function printf(format: *[u8], ..) -> u32;

foreign function malloc(size_bytes: usize) -> *mut void;
foreign function free(alloc: *mut void);
foreign function memcpy(dest: *mut void, src: *void, byte_count: usize) -> *mut void;

foreign function strlen(str: *[u8]) -> u64;
foreign function isdigit(char: i32) -> i32;

implement u8 {
    function swap(mut self: *mut Self, mut other: *mut Self) {
        let temp = *self;
        *self = *other;
        *other = temp;
    }
}

implement usize {
    function max(self: Self, other: Self) -> Self {
        if (self > other) {
            self
        }
        else {
            other
        }
    }
}

struct Str {
    ptr: *[u8],
    length: usize,
}

implement Str {
    function raw_parts(self: *Self) -> (*[u8], usize) {
        (self.ptr, self.length)
    }
}

struct MutStr {
    ptr: *mut [u8],
    length: usize,
}

implement MutStr {
    function as_str(self: *Self) -> Str {
        Str {
            ptr: self.ptr,
            length: self.length,
        }
    }
}

struct String {
    str: MutStr,
    capacity: usize,
}

implement String {
    function new() -> Self {
        Self {
            str: MutStr {
                ptr: null,
                length: 0,
            },
            capacity: 0,
        }
    }

    function del(self: Self) {
        free(self.str.ptr as *mut void);
    }

    function as_str(self: *Self) -> Str {
        self.str.as_str()
    }

    function grow_by(mut self: *mut Self, additional: usize) {
        let required_capacity = self.capacity + additional;
        let capacity = usize::max(self.capacity * 2, required_capacity);
        let mut ptr = malloc(sizeof(u8) * capacity) as *mut [u8];

        memcpy(ptr as *mut void, self.str.ptr as *void, self.str.length);
        free(self.str.ptr as *mut void);

        self.str.ptr = ptr;
        self.capacity = capacity;
    }

    function push(mut self: *mut Self, ch: u8) {
        if (self.str.length == self.capacity) {
            self.grow_by(1);
        }

        self.str.ptr[self.str.length] = ch;
        self.str.length += 1;
    }

    function insert(mut self: *mut Self, mut index: usize, mut ch: u8) {
        if (self.str.length == self.capacity) {
            self.grow_by(1);
        }

        while (index < self.str.length) {
            self.str.ptr[index].swap(&ch);
            index += 1;
        }

        self.str.ptr[self.str.length] = ch;
        self.str.length += 1;
    }
}

function fibonacci(limit: i32) -> i32 {
    let mut a = 0_i32;
    let mut b = 1_i32;

    while (b < limit) {
        let temp = a + b;
        a = b;
        b = temp;
    }

    a
}

function gcd(mut a: u32, mut b: u32) -> u32 {
    while (b >= 1) {
        let temp = a % b;
        a = b;
        b = temp;
    }

    a
}

function aoc_01_p1() {
    let mut input = fopen("day01.txt", "r");
    if (input == null) {
        printf("unable to open input file\n");
        return;
    }

    let mut calibration_sum = 0_u32;

    let mut line: [u8; 100];
    while (fgets(&line, 100, input) != null) {
        // Start at the beginning of the line
        let mut index = 0_u64;

        // Find the first digit
        while (isdigit(line[index] as i32) == 0) {
            index += 1;
        }
        let calibration_value = (line[index] - '0') as u32;

        // Go to the end of the line
        index = strlen(&line) - 1;

        // Backtrack to find the last digit
        while (isdigit(line[index] as i32) == 0) {
            index -= 1;
        }
        let calibration_value = calibration_value * 10 + (line[index] - '0') as u32;

        // Add the found value to the sum
        calibration_sum += calibration_value;
    }

    fclose(input);

    printf("[01p1] Sum of calibration values: %d\n", calibration_sum);
}

struct Node {
    value: *[u8],
    next: *mut Self,
}

function omg_linked_list(values: *[*[u8]], value_count: usize) {
    let mut head: *mut Node = null;

    let mut index = 0_usize;
    while (index < value_count) {
        let mut node = malloc(sizeof(Node)) as *mut Node;
        *node = Node {
            value: values[index],
            next: head,
        };
        head = node;

        index += 1;
    }

    printf("Reversed:\n");
    while (head != null) {
        let node = head;

        printf("%s\n", node.value);
        head = node.next;

        free(node as *mut void);
    }
}

struct Student {
    name: *[u8],
    age: u32,
    grades: [u32; 4],
}

function student_stuff() {
    let joe_age = 97_u32;
    let joe_calculus_grade_before_curve = 47_u32;

    let joe = Student {
        age: joe_age,
        grades: [80, 100, 92, joe_calculus_grade_before_curve + 15],
        name: "Joe Mama",
    };

    printf("Name: %s\n", joe.name);
    printf("Age: %u\n", joe.age);
    printf("Grades: %u, %u, %u, %u\n", joe.grades[0], joe.grades[1], joe.grades[2], joe.grades[3]);
}

implement i64 {
    function to_string(mut self: Self) -> String {
        let mut string = String::new();

        if (self == 0) {
            string.push('0');
        }
        else {
            let is_negative = self < 0;
            if (is_negative) {
                self = -self;
            }

            while (self != 0) {
                string.insert(0, (self % 10) as u8 + '0');
                self /= 10;
            }
            if (is_negative) {
                string.insert(0, '-');
            }
        }

        string
    }
}

let global_var: i32 = 5;
let const global_const: *[u8] = "I am a string";

foreign function main() -> i32 {
    aoc_01_p1();

    student_stuff();

    let values: [*[u8]; 4] = [
        "Value 1",
        "Value 2",
        "Value 3",
        "Value 4",
    ];

    omg_linked_list(&values, 4);

    let mut string = String::new();
    string.push('H');
    string.push('e');
    string.push('l');
    string.push('l');
    string.push('o');
    string.push(' ');
    string.push('w');
    string.push('o');
    string.push('r');
    string.push('l');
    string.push('d');
    string.push('!');
    string.push('\0');
    let str = string.as_str();
    printf("%s\n", str.ptr);
    string.del();

    let mut number_string = (-12345_i64).to_string();
    number_string.push('\0');
    printf("i64::to_string: \"%s\"\n", number_string.str.ptr);
    number_string.del();

    0
}
