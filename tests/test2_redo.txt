// (1) = first (outline) pass
// (2) = second (fill) pass

foreign function printf(format: *[u8], ..) -> u32;
// (1) namespace ::module {printf: value}
// (2) namespace ::module {printf: value(function(*[u8], ..) -> u32)}

function main() -> i32 {
    let vector: [i32; 2] = [4, 8];
    printf("(%d, %d)\n", vector.x(), vector.y());
    return 0;
}
// (1) namespace ::module {printf: _, main: value}
// (2) namespace ::module {printf: _, main: value(function() -> i32)}

implement [i32; 2] {
    function x(self: *Self) -> i32 {
        return self[0];
    }
    // (2) namespace <[i32; 2]> {x: value(function(*[i32; 2]) -> i32)}

    function y(self: *Self) -> i32 {
        return self[1];
    }
    // (2) namespace <[i32; 2]> {x: _, y: value(function(*[i32; 2]) -> i32)}
}

struct First {}
// (1) type $0: undef
// (1) namespace ::module {printf: _, main: _, First: type($0)}
// (2) type $0: struct First {}

module thing {
    // (1) namespace ::module {printf: _, main: _, First: _, thing: module(::thing)}
    // (1) namespace ::thing {}

    import super::*;
    // (1) namespace ::thing {} globs ::module

    struct Thing {
        x: *Test,
        y: *First,
        z: *Self,
    }
    // (1) type $1: undef
    // (1) namespace ::thing {Thing: type($1)} globs ::module
    // (2) type $1: struct Thing {x: *$2, y: *$0, z: *$1}
}

struct Test {
    a: *test::Test,
    b: *test::test::Test,
    c: *thing::Thing,
}
// (1) type $2: undef
// (1) namespace ::module {printf: _, main: _, First: _, thing: _, Test: type($2)}
// (2) type $2: struct Test {a: *$3, b: *$4, c: *$1}

module test {
    // (1) namespace ::module {printf: _, main: _, First: _, thing: _, Test: _, test: module(::test)}
    // (1) namespace ::test {}

    import super::thing::Thing;
    // (1) namespace ::test {Thing: alias(::thing::Thing)}

    struct Test {
        a: *super::Test,
        b: *test::Test,
        c: *Thing,
    }
    // (1) type $3: undef
    // (1) namespace ::test {Thing: _, Test: type($3)}
    // (2) type $3: struct Test {a: *$2, b: *$4, c: *$1}

    module test {
        // (1) namespace ::test {Thing: _, Test: _, test: module(::test::test)}
        // (1) namespace ::test::test {}

        import super::Thing;
        // (1) namespace ::test::test {Thing: alias(::test::Thing)}
        // (2) namespace ::test::test {Thing: alias(::thing::Thing), SuperTest: _, Test: _}

        import super::Test as SuperTest;
        // (1) namespace ::test::test {Thing: _, SuperTest: alias(::test::Test)}

        implement Test {
            function do_thing(self: *Self, x: i32) -> i32 {
                return x * x;
            }
            // (2) namespace ::test::test::Test {do_thing: value(function(*$4, i32) -> i32)}
        }

        struct Test {
            a: *super::super::Test,
            b: *SuperTest,
            c: *Thing,
        }
        // (1) type $4: undef
        // (1) namespace ::test::test {Thing: _, SuperTest: _, Test: type($4)}
        // (2) type $4: struct Test {a: *$2, b: *$3, c: *$1}
    }
}

// TYPES
// $0 (::First) => struct First {}
// $1 (::thing::Thing) => struct Thing {x: *$2, y: *$0, z: *$1}
// $2 (::Test) => struct Test {a: *$3, b: *$4, c: *$1}
// $3 (::test::Test) => struct Test {a: *$2, b: *$4, c: *$1}
// $4 (::test::test::Test) => struct Test {a: *$2, b: *$3, c: *$1}

// SYMBOLS
// ::First => type($0)
// ::main => value(function() -> i32)
// ::printf => value(function(*[u8], ..) -> u32)
// ::Test => type($2)
// ::test => module(::test)
// ::test::Test => type($3)
// ::test::Thing => alias(::thing::Thing)
// ::test::test => module(::test::test)
// ::test::test::SuperTest => alias(::test::Test)
// ::test::test::Test => type($4)
// ::test::test::Test::do_thing => value(function(*$4, i32) -> i32)
// ::test::test::Thing => alias(::thing::Thing)
// ::thing => module(::thing)
// ::thing::Thing => type($1)
// <[i32; 2]>::x => value(function(*[i32; 2]) -> i32)
// <[i32; 2]>::y => value(function(*[i32; 2]) -> i32)
