foreign function malloc(size_bytes: u64) -> *mut void;
foreign function free(alloc: *mut void);
foreign function printf(format: *[u8], ..) -> u32;

implement i32 {
    function max(self: Self, other: Self) -> Self {
        if (self > other) {
            return self;
        }
        else {
            return other;
        }
    }

    function cmp(self: *Self, other: *Self) -> i32 {
        if (*self < *other) {
            return -1;
        }
        else if (*self > *other) {
            return +1;
        }
        else {
            return 0;
        }
    }

    function print(self: *Self) {
        printf("%d", *self);
    }
}

struct LinkedListNode {
    value: *void,
    next: *mut Self,
}

struct LinkedList {
    head: *mut LinkedListNode,
}

implement LinkedList {
    function new() -> Self {
        return Self {
            head: null,
        };
    }

    function front(self: *Self) -> *void {
        if (self.head == null) {
            return null;
        }
        else {
            return self.head.value;
        }
    }

    function push_front(mut self: *mut Self, value: *void) {
        let mut new_node = malloc(sizeof(LinkedListNode)) as *mut LinkedListNode;
        *new_node = LinkedListNode {
            value: value,
            next: self.head,
        };
        self.head = new_node;
    }

    function pop_front(mut self: *mut Self) -> *void {
        if (self.head == null) {
            return null;
        }
        else {
            let front = self.head;
            let value = front.value;
            self.head = front.next;
            free(front);
            return value;
        }
    }
}

struct AVLTreeNode {
    key: *void,
    left: *mut Self,
    right: *mut Self,
    height: i32,
}

implement AVLTreeNode {
    function alloc(key: *void) -> *mut Self {
        let mut alloc = malloc(sizeof(Self)) as *mut Self;
        *alloc = Self {
            key: key,
            left: null,
            right: null,
            height: 0,
        };
        return alloc;
    }

    function get_height(self: *Self) -> i32 {
        // sneaky little trick
        if (self == null) {
            return -1;
        }
        else {
            return self.height;
        }
    }

    function recompute_height(mut self: *mut Self) {
        self.height = 1 + i32::max(
            self.left.get_height(),
            self.right.get_height(),
        );
    }

    function rotate_right(mut self: *mut Self) -> *mut Self {
        let mut new_root = self.left;
        self.left = new_root.right;
        new_root.right = self;
        self.recompute_height();
        new_root.recompute_height();
        return new_root;
    }

    function rotate_left(mut self: *mut Self) -> *mut Self {
        let mut new_root = self.right;
        self.right = new_root.left;
        new_root.left = self;
        self.recompute_height();
        new_root.recompute_height();
        return new_root;
    }

    function balance(mut self: *mut Self) -> *mut Self {
        if (self == null) {
            return null;
        }
        let imbalance = self.left.get_height() - self.right.get_height();
        if (imbalance > 1) {
            if (self.left.right.get_height() > self.left.left.get_height()) {
                self.left = self.left.rotate_left();
            }
            self = self.rotate_right();
        }
        else if (imbalance < -1) {
            if (self.right.left.get_height() > self.right.right.get_height()) {
                self.right = self.right.rotate_right();
            }
            self = self.rotate_left();
        }
        else {
            self.recompute_height();
        }
        return self;
    }

    function print(self: *Self, printer: function(*void)) {
        if (self != null) {
            printf("(");
            self.left.print(printer);
            printf(" ");
            printer(self.key);
            printf(" ");
            self.right.print(printer);
            printf(")");
        }
    }
}

struct AVLTree {
    root: *mut AVLTreeNode,
    comparator: function(*void, *void) -> i32,
}

implement AVLTree {
    function new(comparator: function(*void, *void) -> i32) -> Self {
        return Self {
            root: null,
            comparator: comparator,
        };
    }

    function get(self: *Self, key: *void) -> *void {
        let mut node = self.root;
        while (node != null) {
            let ordering = (self.comparator)(key, node.key);
            if (ordering < 0) {
                node = node.left;
            }
            else if (ordering > 0) {
                node = node.right;
            }
            else {
                return node.key;
            }
        }
        return null;
    }

    function insert_subtree(mut self: *mut Self, mut node_ref: *mut *mut AVLTreeNode, key: *void) -> *void {
        if (*node_ref == null) {
            *node_ref = AVLTreeNode::alloc(key);
            return null;
        }
        let ordering = (self.comparator)(key, (*node_ref).key);
        if (ordering < 0) {
            self.insert_subtree(&(*node_ref).left, key);
        }
        else if (ordering > 0) {
            self.insert_subtree(&(*node_ref).right, key);
        }
        else {
            let replaced_key = (*node_ref).key;
            (*node_ref).key = key;
            return replaced_key;
        }
        *node_ref = (*node_ref).balance();
        return null;
    }

    function insert(mut self: *mut Self, key: *void) -> *void {
        return self.insert_subtree(&self.root, key);
    }

    function print(self: *Self, printer: function(*void)) {
        self.root.print(printer);
        printf("\n");
    }
}

struct BTreeNodeKey {
    boundary: *void,
    left: *mut BTreeNode,
}

struct BTreeNode {
    is_leaf: bool,
    degree: u64,
    keys: *mut [BTreeNodeKey],
    right: *mut Self,
}

struct BTreeLeaf {
    is_leaf: bool,
    degree: u64,
    elements: *mut [*void],
}

implement BTreeLeaf {
    function alloc(l_order: u64, first_element: *void) -> *mut Self {
        let mut elements = malloc(sizeof(*void) * l_order) as *mut [*void];
        elements[0] = first_element;
        let mut alloc = malloc(sizeof(Self)) as *mut Self;
        *alloc = Self {
            is_leaf: true,
            degree: 1,
            elements: elements,
        };
        return alloc;
    }
}

struct BTree {
    m_order: u64,
    l_order: u64,
    comparator: function(*void, *void) -> i32,
    root: *mut BTreeNode,
}

implement BTree {
    function new(m_order: u64, l_order: u64, comparator: function(*void, *void) -> i32) -> Self {
        return Self {
            m_order: m_order,
            l_order: l_order,
            comparator: comparator,
            root: null,
        };
    }

    function insert(mut self: *mut Self, key: *void) -> *void {
        if (self.root == null) {
            self.root = BTreeLeaf::alloc(self.l_order, key) as *mut BTreeNode;
            return null;
        }
        return null;
    }
}

function max_percolate_dmut(mut array: *mut [*void], length: u64, comparator: function(*void, *void) -> i32, mut index: u64) {
    let target = array[index];
    while (true) {
        let left = (index + 1) * 2 - 1;
        let right = left + 1;
        if (left >= length) {
            break;
        }
        let mut max: u64;
        if (right >= length) {
            max = left;
        }
        else if (comparator(array[left], array[right]) > 0) {
            max = left;
        }
        else {
            max = right;
        }
        if (comparator(array[max], target) > 0) {
            array[index] = array[max];
            index = max;
        }
        else {
            break;
        }
    }
    array[index] = target;
}

function heap_sort(mut array: *mut [*void], length: u64, comparator: function(*void, *void) -> i32) {
    // Build max heap
    let mut index = length / 2;
    while (index > 0) {
        index -= 1;
        // Percolate dmut
        max_percolate_dmut(array, length, comparator, index);
    }
    // Build sorted array
    index = length;
    while (index > 1) {
        index -= 1;
        // Swap max with last unsorted element
        let max_value = array[0];
        array[0] = array[index];
        array[index] = max_value;
        // Percolate the root dmut within the unsorted range
        max_percolate_dmut(array, index, comparator, 0);
    }
}

function print_i32_ptr_array(array: *[*i32], length: u64) {
    if (length == 0) {
        printf("[]");
        return;
    }
    printf("[%d", *array[0]);
    let mut index: u64 = 1;
    while (index < length) {
        printf(", %d", *array[index]);
        index += 1;
    }
    printf("]");
}

foreign function main() -> i32 {
    let keys: [i32; 15] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

    let mut list = LinkedList::new();
    let mut i: u64 = 0;
    while (i < 5) {
        printf("push: %d\n", keys[i]);
        list.push_front(&keys[i]);
        i += 1;
    }
    let mut value: *i32;
    while ((value = list.pop_front()) != null) {
        printf("pop: %d\n", *value);
    }

    let mut tree = AVLTree::new(i32::cmp);
    let mut i: u64 = 0;
    while (i < 7) {
        let idx = (i * 7) % 10;
        printf("insert: %d\n", keys[idx]);
        tree.insert(&keys[idx]);
        i += 1;
    }
    let mut i: u64 = 0;
    while (i < 10) {
        let key = tree.get(&keys[i]);
        let mut is_contained: *[u8];
        if (key != null) {
            is_contained = "yes";
        }
        else {
            is_contained = "no";
        }
        printf("contains %d: %s\n", keys[i], is_contained);
        i += 1;
    }
    tree.print(i32::print);

    let mut b_tree = BTree::new(3, 2, i32::cmp);
    b_tree.insert(&keys[0]);

    let mut heap_sort_test: [*i32; 15];
    let mut index: u64 = 0;
    while (index < 15) {
        let key = &keys[((index + 7) * 7) % 15];
        heap_sort_test[index] = key;
        index += 1;
    }
    printf("unsorted: ");
    print_i32_ptr_array(&heap_sort_test, 15);
    printf("\n");
    heap_sort(&heap_sort_test, 15, i32::cmp);
    printf("heapsort: ");
    print_i32_ptr_array(&heap_sort_test, 15);
    printf("\n");

    return 0;
}
