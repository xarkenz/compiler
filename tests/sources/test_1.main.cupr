module libc;

implement u8 {
    function swap(self: *mut Self, other: *mut Self) {
        let temp = *self;
        *self = *other;
        *other = temp;
    }
}

implement usize {
    function max(self: Self, other: Self) -> Self {
        if (self > other) {
            self
        }
        else {
            other
        }
    }
}

struct Str {
    ptr: *[u8],
    length: usize,
}

implement Str {
    function raw_parts(self: *Self) -> (*[u8], usize) {
        (self.ptr, self.length)
    }
}

struct MutStr {
    ptr: *mut [u8],
    length: usize,
}

implement MutStr {
    function as_str(self: *Self) -> Str {
        Str {
            ptr: self.ptr,
            length: self.length,
        }
    }
}

struct String {
    str: MutStr,
    capacity: usize,
}

implement String {
    function new() -> Self {
        Self {
            str: MutStr {
                ptr: null,
                length: 0,
            },
            capacity: 0,
        }
    }

    function del(self: Self) {
        libc::free(self.str.ptr);
    }

    function as_str(self: *Self) -> Str {
        self.str.as_str()
    }

    function grow_by(self: *mut Self, additional: usize) {
        let required_capacity = self.capacity + additional;
        let capacity = usize::max(self.capacity * 2, required_capacity);

        let ptr = libc::malloc(sizeof(u8) * capacity);
        libc::memcpy(ptr, self.str.ptr, self.str.length);
        libc::free(self.str.ptr);

        self.str.ptr = ptr;
        self.capacity = capacity;
    }

    function push(self: *mut Self, ch: u8) {
        if (self.str.length == self.capacity) {
            self.grow_by(1);
        }

        self.str.ptr[self.str.length] = ch;
        self.str.length += 1;
    }

    function insert(self: *mut Self, mut index: usize, mut ch: u8) {
        if (self.str.length == self.capacity) {
            self.grow_by(1);
        }

        while (index < self.str.length) {
            self.str.ptr[index].swap(&ch);
            index += 1;
        }

        self.str.ptr[self.str.length] = ch;
        self.str.length += 1;
    }
}

function fibonacci(limit: i32) -> i32 {
    let mut a = 0_i32;
    let mut b = 1_i32;

    while (b < limit) {
        let temp = a + b;
        a = b;
        b = temp;
    }

    a
}

function gcd(mut a: u32, mut b: u32) -> u32 {
    while (b >= 1) {
        let temp = a % b;
        a = b;
        b = temp;
    }

    a
}

function aoc_01_p1() {
    let mut input = libc::fopen("day01.txt", "r");
    if (input == null) {
        libc::printf("unable to open input file\n");
        return;
    }

    let mut calibration_sum = 0_u32;

    let mut line: [u8; 100];
    while (libc::fgets(&line, 100, input) != null) {
        // Start at the beginning of the line
        let mut index = 0_usize;

        // Find the first digit
        while (libc::isdigit(line[index] as i32) == 0) {
            index += 1;
        }
        let calibration_value = (line[index] - '0') as u32;

        // Go to the end of the line
        index = libc::strlen(&line) - 1;

        // Backtrack to find the last digit
        while (libc::isdigit(line[index] as i32) == 0) {
            index -= 1;
        }
        let calibration_value = calibration_value * 10 + (line[index] - '0') as u32;

        // Add the found value to the sum
        calibration_sum += calibration_value;
    }

    libc::fclose(input);

    libc::printf("[01p1] Sum of calibration values: %d\n", calibration_sum);
}

struct Node {
    value: *[u8],
    next: *mut Self,
}

function omg_linked_list(values: *[*[u8]], value_count: usize) {
    let mut head: *mut Node = null;

    let mut index = 0_usize;
    while (index < value_count) {
        let node = libc::malloc(sizeof(Node)) as *mut Node;
        *node = Node {
            value: values[index],
            next: head,
        };
        head = node;

        index += 1;
    }

    libc::printf("Reversed:\n");
    while (head != null) {
        let node = head;

        libc::printf("%s\n", node.value);
        head = node.next;

        libc::free(node as *mut [u8]);
    }
}

struct Student {
    name: *[u8],
    age: u32,
    grades: [u32; 4],
}

function student_stuff() {
    let joe_age = 97_u32;
    let joe_calculus_grade_before_curve = 47_u32;

    let joe = Student {
        age: joe_age,
        grades: [80, 100, 92, joe_calculus_grade_before_curve + 15],
        name: "Joe Mama",
    };

    libc::printf("Name: %s\n", joe.name);
    libc::printf("Age: %u\n", joe.age);
    libc::printf("Grades: %u, %u, %u, %u\n", joe.grades[0], joe.grades[1], joe.grades[2], joe.grades[3]);
}

implement i64 {
    function to_string(mut self: Self) -> String {
        let mut string = String::new();

        if (self == 0) {
            string.push('0');
        }
        else {
            let is_negative = self < 0;
            if (is_negative) {
                self = -self;
            }

            while (self != 0) {
                string.insert(0, (self % 10) as u8 + '0');
                self /= 10;
            }
            if (is_negative) {
                string.insert(0, '-');
            }
        }

        string
    }
}

let global_var: i32 = 5;
let const global_const: *[u8] = "I am a string";

foreign function main() -> i32 {
    aoc_01_p1();

    student_stuff();

    let values: [*[u8]; 4] = [
        "Value 1",
        "Value 2",
        "Value 3",
        "Value 4",
    ];

    omg_linked_list(&values, 4);

    let mut string = String::new();
    string.push('H');
    string.push('e');
    string.push('l');
    string.push('l');
    string.push('o');
    string.push(' ');
    string.push('w');
    string.push('o');
    string.push('r');
    string.push('l');
    string.push('d');
    string.push('!');
    string.push('\0');
    let str = string.as_str();
    libc::printf("%s\n", str.ptr);
    string.del();

    let mut number_string = (-12345_i64).to_string();
    number_string.push('\0');
    libc::printf("i64::to_string: \"%s\"\n", number_string.str.ptr);
    number_string.del();

    0
}
