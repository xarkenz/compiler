import std::string::String;

function fibonacci(limit: i32) -> i32 {
    let mut a = 0_i32;
    let mut b = 1_i32;

    while (b < limit) {
        let temp = a + b;
        a = b;
        b = temp;
    }

    a
}

function gcd(mut a: u32, mut b: u32) -> u32 {
    while (b >= 1) {
        let temp = a % b;
        a = b;
        b = temp;
    }

    a
}

function aoc_01_p1() {
    let mut input = libc::fopen("test_1/day01.txt", "r");
    if (input == null) {
        libc::puts("unable to open input file");
        return;
    }

    let mut calibration_sum = 0_u32;

    let mut line: [u8; 100];
    while (libc::fgets(&line, 100, input) != null) {
        // Start at the beginning of the line
        let mut index = 0_usize;

        // Find the first digit
        while (libc::isdigit(line[index] as i32) == 0) {
            index += 1;
        }
        let calibration_value = (line[index] - '0') as u32;

        // Go to the end of the line
        index = libc::strlen(&line) - 1;

        // Backtrack to find the last digit
        while (libc::isdigit(line[index] as i32) == 0) {
            index -= 1;
        }
        let calibration_value = calibration_value * 10 + (line[index] - '0') as u32;

        // Add the found value to the sum
        calibration_sum += calibration_value;
    }

    libc::fclose(input);

    libc::printf("[01p1] Sum of calibration values: %d\n", calibration_sum);
}

struct Node {
    value: *[u8],
    next: *mut Self,
}

function omg_linked_list(values: *[*[u8]], value_count: usize) {
    let mut head: *mut Node = null;

    let mut index = 0_usize;
    while (index < value_count) {
        let node = libc::malloc(sizeof(Node)) as *mut Node;
        *node = Node {
            value: values[index],
            next: head,
        };
        head = node;

        index += 1;
    }

    libc::puts("Reversed:");
    while (head != null) {
        let node = head;

        libc::printf("%s\n", node.value);
        head = node.next;

        libc::free(node as *mut [u8]);
    }
}

struct Student {
    name: *[u8],
    age: u32,
    grades: [u32; 4],
}

function student_stuff() {
    let joe_age = 97_u32;
    let joe_calculus_grade_before_curve = 47_u32;

    let joe = Student {
        age: joe_age,
        grades: [80, 100, 92, joe_calculus_grade_before_curve + 15],
        name: "Joe Mama",
    };

    libc::printf("Name: %s\n", joe.name);
    libc::printf("Age: %u\n", joe.age);
    libc::printf("Grades: %u, %u, %u, %u\n", joe.grades[0], joe.grades[1], joe.grades[2], joe.grades[3]);
}

implement i64 {
    function to_string(mut self: Self) -> String {
        let mut string = String::new();

        if (self == 0) {
            string.push('0');
        }
        else {
            let is_negative = self < 0;
            if (is_negative) {
                self = -self;
            }

            while (self != 0) {
                string.insert(0, (self % 10) as u8 + '0');
                self /= 10;
            }
            if (is_negative) {
                string.insert(0, '-');
            }
        }

        string
    }
}

let mut static_mut_var: i32 = 5;
let static_var: *[u8] = "I am a string";

foreign function main() -> i32 {
    aoc_01_p1();

    student_stuff();

    let values: [*[u8]; 4] = [
        "Value 1",
        "Value 2",
        "Value 3",
        "Value 4",
    ];

    omg_linked_list(&values, 4);

    let mut string = String::new();
    string.push('H');
    string.push('e');
    string.push('l');
    string.push('l');
    string.push('o');
    string.push(' ');
    string.push('w');
    string.push('o');
    string.push('r');
    string.push('l');
    string.push('d');
    string.push('!');
    string.push('\0');
    let str = string.as_str();
    libc::puts(str.ptr);
    string.del();

    let mut number_string = (-12345_i64).to_string();
    number_string.push('\0');
    libc::printf("i64::to_string: \"%s\"\n", number_string.str.ptr);
    number_string.del();

    0
}
